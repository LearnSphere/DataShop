/*
 * Carnegie Mellon University, Human Computer Interaction Institute
 * Copyright 2014
 * All Rights Reserved
 */

package edu.cmu.pslc.datashop.problemcontent.oli;

import edu.cmu.pslc.datashop.problemcontent.PopulatePcTables;
import edu.cmu.pslc.datashop.problemcontent.Constants;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.jdom.Document;
import org.jdom.Element;

import edu.cmu.pslc.datashop.util.FileUtils;

/**
 * Extracts the problem hierarchy information for each workbook included
 * in the sequence list of an organization file and makes this data
 * available to other classes.
 * @author mkomisin
 *
 */
public class Organization {

    /** Used to delimit the hierarchies generated by parsing organization files. */
    private String hierarchyDelim = "/";

    /** The maximum length for any file path. */
    private static final Integer MAX_OS_PATH_LENGTH = 255;

    /** The calculated maximum length for any hiearchy-based file path. */
    private static Integer maxFilePathLength;

    /** The organization id. */
    private String id;

    /** Debug logging. */
    private Logger logger = Logger.getLogger(getClass().getName());

    /** Organization file. */
    private File organizationFile;

    /** Full content path, e.g. a_and_p_v_1_2-prod-2013-04-11. */
    private String pathPrefix;

    /** List of workbooks in this organization. */
    private List<Workbook> workbooks;

    /** Maps resourceref Ids to their parent item's Id. */
    private Map<String, String> workbookContainerMap;

    /** Maps the parent element Ids to their titles (sequence, unit, module, and section). */
    private Map<String, String> titleMap;

    /** A map of shortened titles and their count to deal with file system limitations. */
    private Map<String, Integer> shortenedTitles = null;

    /** Maps activities to a workbook page. */
    private Map<String, Element> activityMap;

    /** Maps actual learning objectives to a workbook page. */
    private Map<Element, List<String>> learningObjectiveMap;

    /** Maps inline assessments to a workbook page. */
    private Map<String, Element> inlineMap;

    /** Maps any type of activity, objective, or assessment to a workbook page. */
    private Map<String, String> elementIdMap;

    /** Maps assessments to an assessment page. */
    private Map<String, String> elementAssessmentMap;

    /** The workbook titles from the workbook pages keyed on workbookId. */
    private Map<String, String> workbookTitles;

    /** The hierarchy descriptions from the organization page keyed on hierarchy. */
    private Map<String, String> hierarchyDescriptions;

    /**
     * Constructor.
     * @param pathPrefix the course_name + course_version string
     * @param organizationFile the organization file
     */
    public Organization(String pathPrefix, File organizationFile) {

        this.organizationFile = organizationFile;
        this.pathPrefix = pathPrefix;
        workbooks = new ArrayList<Workbook>();
        workbookContainerMap = new HashMap<String, String>();
        titleMap = new HashMap<String, String>();
        activityMap = new HashMap<String, Element>();
        learningObjectiveMap = new HashMap<Element, List<String>>();
        inlineMap = new HashMap<String, Element>();
        elementIdMap = new HashMap<String, String>();
        elementAssessmentMap = new HashMap<String, String>();
        workbookTitles = new HashMap<String, String>();
        hierarchyDescriptions = new HashMap<String, String>();
        shortenedTitles = new HashMap<String, Integer>();

        maxFilePathLength = MAX_OS_PATH_LENGTH - pathPrefix.length()
            - OliConverter.BASE_PROBLEM_CONTENT_PATH.length()
            - PopulatePcTables.OUTPUT_DIRECTORY_STR.length()
            - Constants.OLI_DIR_PART.length()
            - ".html".length();

        List sequenceList = getSequenceList();
        resolveWorkbooksToHierarchies(sequenceList);

    }

    /**
     * Copies the organization file to the output path if it exists.
     * @param baseContentPath the output directory
     *
     */
    public void copyToOutput(String baseContentPath) {

        String resourcePath = organizationFile.getAbsolutePath().replaceAll("\\\\", "/");
        String orgPattern = "organizations" + "/";
        Integer beginIndex = resourcePath.indexOf(orgPattern)
                    + orgPattern.length();
        Integer endIndex = resourcePath.lastIndexOf(organizationFile.getName());
        String orgBaseDir = resourcePath.substring(beginIndex, endIndex);
        String orgFileDir = baseContentPath
                + "/" + "organizations"
                + "/" + orgBaseDir;
        File mkDir = CommonXml
                .createDirectory(orgFileDir);
        String filePath = orgFileDir + "/" + organizationFile.getName();
        File newResourceFile = new File (filePath);
        try {


            if (FileUtils.copyFile(organizationFile, newResourceFile)) {
                logger.debug("Copied organization file: "
                        + organizationFile.getAbsolutePath() + " to \n"
                        + newResourceFile.getAbsolutePath());
            } else {

                    logger.error("Could not copy resource file: "
                            + organizationFile.getAbsolutePath() + " to \n"
                            + newResourceFile.getAbsolutePath());
            }
        } catch (IOException e) {
            logger.error("IOException thrown while trying to read"
                + " the organization file " + filePath + ". Skipping copy.");
        }
    }

    /**
     * Get the sequence elements from an organization.
     * @return the sequence elements
     */
    public List<Element> getSequenceList() {
        Document xmlOutput = new Document(new Element("dummy_root"));
        Document doc = CommonXml.getDocument(organizationFile);

        Element root = doc.getRootElement();
        List<Element> sequenceList = new ArrayList<Element>();

        if (root.getName().equals("organization")) {
            if (root.getAttributeValue("id") != null) {
                this.id = root.getAttributeValue("id");
            } else {
                logger.error("The organization element does not contain an Id attribute in "
                        + organizationFile.getAbsolutePath() + ". Skipping organization.");
                return null;
            }
            logger.debug("Getting sequences from organization file: " + organizationFile
                    .getAbsolutePath());
            List<Element> sequenceElements = CommonXml.getElementsByTagName(root, "sequence");

            // Detach elements before adding them to list so that we can attach them elsewhere
            for (Element sequence : sequenceElements) {
                sequence.detach();
                sequenceList.add(sequence);
                logger.debug("Sequence found: " + sequence.getAttribute("id"));
            }
        }
        return sequenceList;
    }

    /**
     * Traverse the sequence tree to uncover the organization layout
     * when courses, units, modules, or sections are not used.
     * @param element the element (sequence, unit, module, or section)
     * @param hierarchyPrefix the prefix for the title (i.e., hierarchy)
     * @return the hierarchy for this item
     */
    private String traverseSequence(Element element, String hierarchyPrefix) {
        String tag = element.getName();
        String hierarchy = null;
        if (tag.equals("sequence") || tag.equals("unit")
                || tag.equals("module") || tag.equals("section")) {
            String elementTitle = element.getChildText("title").trim();

            String elementDescription = element.getChildText("description");
            String elementId = element.getAttributeValue("id");
            if (hierarchyPrefix != null) {
                hierarchy = hierarchyPrefix + hierarchyDelim + elementTitle;
            } else {
                hierarchy = elementTitle;
            }

            if (hierarchy == null) {
                hierarchy = OliConverter.UNREFERENCED_CONTENT;
            }

            hierarchy = hierarchy.replaceAll("&", "&amp;")
                .replaceAll(">", "&gt;")
                    .replaceAll("<", "&lt;");

            logger.debug("Adding workbook " + elementId + " to hierarchy " + hierarchy);
            String shortenedHierarchy = formatHierarchyTitle(this.pathPrefix, hierarchy);
            titleMap.put(elementId, shortenedHierarchy);
            if (elementDescription != null) {
                hierarchyDescriptions.put(shortenedHierarchy, elementDescription.trim());
            }

            mapResourceRefs(element);
            Iterator childIter = element.getChildren().iterator();
            while (childIter.hasNext()) {
                Element child = (Element) childIter.next();
                traverseSequence(child, hierarchy);
            }
        }
        return hierarchy;
    }

    /**
     * Formats the hierarchy title to prevent names that are too long for file systems
     * by truncating the longest directory names, first. Factor in the length of the
     * prefix, and use an appended count as a unique identifier for directory names.
     * @param prefixPath the prefixed path to the course content package
     * @param hierarchyTitle the hierarchy title
     * @return the formatted hierarchy title
     */
    @SuppressWarnings("unchecked")
    public String formatHierarchyTitle(String prefixPath, String hierarchyTitle) {

        StringBuffer newFullPath = new StringBuffer("");

        String[] pathPartsArray = hierarchyTitle.split(hierarchyDelim);
        ArrayList<String> pathParts = new ArrayList<String>(Arrays.asList(pathPartsArray));

        int numDirs = pathPartsArray.length;
        // extraChars is not an actual path, but a string containing all characters
        // that could be prepended or appended to a hierarchyTitle
        String extraChars = prefixPath + hierarchyDelim + ".html";

        int totalLength = hierarchyTitle.length() + extraChars.length();
        // Set the maximum allowed length based on the extra characters and account
        // for the string split on the hierarchyDelim
        int allowedLength = maxFilePathLength
            - extraChars.length() - (numDirs * hierarchyDelim.length());
        boolean isPathChanged = false;

        if (totalLength > allowedLength) {
            // Account for the immutable prefixPath
            int newMaxLength = allowedLength;
            int maxDirLen = newMaxLength / numDirs;


            // Sort the ArrayList by length of strings in desc order
            Collections.sort(pathParts, new Comparator<String>() {
                public int compare(String o1, String o2) {
                    return o2.compareTo(o1);
                }
            });

            int runningLength = totalLength;

            // Now that the list is sorted, start shortening the paths until
            // we satisfy the total file path length constraint
            for (String part : pathParts) {
                int originalIndex = 0;
                while (originalIndex < pathPartsArray.length) {
                    if (part.equals(pathPartsArray[originalIndex])) {
                        break;
                    }
                    originalIndex++;
                }
                // Replace the largest path parts, first, with a shorter version.
                // The length we concatenate to should be based on the smallest required length
                // given the assumption that all path parts are the same size-- this satisfies
                // the worst case scenario.
                if (part.length() > maxDirLen && runningLength > maxFilePathLength) {
                    // Keep track of the total length as it shrinks
                    int thisPartLength = part.length() + hierarchyDelim.length();
                    runningLength -= thisPartLength;
                    // Shorten the path part
                    pathPartsArray[originalIndex] = shortenPathPart(part, maxDirLen);
                    isPathChanged = true;
                    // Keep track of the total length as is adjusted
                    runningLength += pathPartsArray[originalIndex].length();
                }
            }
        }

        // Replace the elements in the pathPartArray with the new path parts
        // to maintain the order of the hierarchy path
        int originalIndex = 0;
        while (originalIndex < pathPartsArray.length) {
            newFullPath.append(pathPartsArray[originalIndex]);
            // Add delimiters but not to the end
            if (originalIndex < pathPartsArray.length - 1) {
                newFullPath.append("/");
            }
            originalIndex++;
        }

        if (isPathChanged) {
            logger.info("Renaming hierarchy path: " + hierarchyTitle
                    + " with length (" + hierarchyTitle.length() + ")");
            logger.info("New hierarchy path: " + newFullPath.toString()
                + " with length (" + newFullPath.toString().length() + ")");
        }

        return newFullPath.toString();

    }


    /**
     * Formats the hierarchy title to prevent names that are too long for file systems.
     * @param part the string to limit
     * @param maxLen the max length of the string
     * @return the formatted hierarchy title
     */
    public String shortenPathPart(String part, int maxLen) {
        String newName = null;
        Integer count = 0;
        if (shortenedTitles.containsKey(part)) {
            count = shortenedTitles.get(part);
            count++;
        }

        shortenedTitles.put(part, count);
        String appendedChars = "-" + count.toString();
        newName = part.substring(0, maxLen - appendedChars.length()) + "-" + count;
        return newName;
    }

    /**
     * Resolve workbook activities and their related information by traversing the
     * organization structure.
     * @param sequenceList the sequence list
     */
    public void resolveWorkbooksToHierarchies(List<Element> sequenceList) {
        // Sequence
        Iterator sequenceIter = sequenceList.iterator();
        while (sequenceIter.hasNext()) {
            Element sequence = (Element) sequenceIter.next();
            traverseSequence(sequence, null);
        }
        for (String key : workbookContainerMap.keySet()) {
            logger.debug("ProblemContainerMap: k(" + key
                + "), v(" + workbookContainerMap.get(key) + ")");
        }
    }

    /**
     * Add a workbook to this organization.
     * @param workbook the workbook
     */
    public void addWorkbook(Workbook workbook) {
        workbookTitles.put(workbook.getWorkbookId(), workbook.getTitle());
        workbooks.add(workbook);
    }

    /**
     * Gets a workbook object by its Id.
     * @param workbookId the workbook Id
     * @return the workbook or null if no workbook is found
     */
    public Workbook getWorkbook(String workbookId) {
        for (Workbook workbook : workbooks) {
            if (workbook.getWorkbookId().equals(workbookId)) {
                return workbook;
            }
        }
        return null;
    }

    /**
     * Maps the resourcerefIds to their parent (sequence, unit, module, or section) Id.
     * @param parentElement the parent element
     */
    private void mapResourceRefs(Element parentElement) {

        logger.debug("Parent element: " + parentElement.getName() + ", id = "
                + parentElement.getAttributeValue("id"));

        Iterator items = parentElement.getChildren("item").iterator();
        while (items.hasNext()) {
            Element item = (Element) items.next();
            Iterator resourceReferenceIter = item.getChildren("resourceref").iterator();
            while (resourceReferenceIter.hasNext()) {
                Element resourceRef = (Element) resourceReferenceIter.next();
                workbookContainerMap.put(resourceRef.getAttributeValue("idref"),
                        parentElement.getAttributeValue("id"));
                logger.debug("Item: " + resourceRef.getAttributeValue("idref")
                        + " maps to " + parentElement.getAttributeValue("id"));
            }
        }

        Iterator itemRefIter = parentElement.getChildren("itemref").iterator();
        while (itemRefIter.hasNext()) {
            Element itemRef = (Element) itemRefIter.next();
            String idref = itemRef.getAttributeValue("idref").replaceFirst("item_", "");
            workbookContainerMap.put(idref,
                    parentElement.getAttributeValue("id"));
            logger.debug("Itemref: " + idref);

        }

        Iterator unorderedIter = parentElement.getChildren("unordered").iterator();
        while (unorderedIter.hasNext()) {
            Element unorderedItem = (Element) unorderedIter.next();
            Iterator resourceReferenceIter = unorderedItem.getChildren("itemref").iterator();
            while (resourceReferenceIter.hasNext()) {
                Element resourceRef = (Element) resourceReferenceIter.next();
                String idref = resourceRef.getAttributeValue("idref").replaceFirst("item_", "");
                workbookContainerMap.put(idref,
                        parentElement.getAttributeValue("id"));
                logger.debug("Unordered Itemref: " + idref);
            }
        }
    }

    /**
     * Adds an inline or activity element to the problemContainerMap.
     * @param inlineId the inline or activity element id
     * @param containerId the container id
     */
    public void addInlineActivity(String inlineId, String containerId) {
        workbookContainerMap.put(inlineId, containerId);
        workbookContainerMap.put(containerId, getContainerFromWorkbook(containerId));
        String title = titleMap.get(getContainerFromWorkbook(containerId));
        if (titleMap.containsKey(containerId) && title != null) {
            titleMap.put(inlineId, title);
            logger.debug("Inline id: " + inlineId + " maps to title: " + titleMap.get(containerId));
        }

        logger.debug("Inline id: " + inlineId + " maps to container: "
            + getContainerFromWorkbook(containerId) + " transversely through "
                + containerId);
    }

    /**
     * Get the container (sequence, unit, module, section)
     * elements associated with a given workbook Id.
     * @param workbookId the workbook Id
     * @return the container element Ids nested within the workbook
     */
    public String getContainerFromWorkbook(String workbookId) {
        String containerId = null;
        // If any keys in the keyset match this workbook Id
        for (String s : workbookContainerMap.keySet()) {
            // Is there a resource reference that matches this workbook page id
            if (s.equals(workbookId)) {
                // If so, then add it to the list
                containerId = workbookContainerMap.get(s);
                break;
            }
        }
        if (containerId != null && !containerId.equals(workbookId)) {
            String parent = getContainerFromWorkbook(containerId);
            if (parent != null) {
                containerId = parent;
            }
        }
        // Return the list of resource reference Ids for this workbook
        return containerId;
    }

    /**
     * Returns the workbook Ids in a given container.
     * @param container the container string
     * @return the workbook Ids in a given container
     *  or null if no Ids are found
     */
    public List<String> getWorkbookIdsForContainer(String container) {
        List<String> workbookIds = new ArrayList<String>();
        if (workbookContainerMap.containsValue(container)) {
            for (String key : workbookContainerMap.keySet()) {
                if (workbookContainerMap.get(key) != null
                    && workbookContainerMap.get(key).equals(container)) {
                    workbookIds.add(key);
                }
            }
            return workbookIds;
        } else {
            return null;
        }
    }

    /**
     * Returns the problem hierarchy string given the element Id.
     * @param id the Id of the sequence, unit, module, or section
     * @return the problem hierarchy string given the element Id
     *  or null if no title found
     */
    public String getHierarchyFromElement(String id) {
        if (titleMap.containsKey(id)) {
            return titleMap.get(id);
        } else {
            return OliConverter.UNREFERENCED_CONTENT;
        }
    }

    /**
     * Returns the element Ids in a given hierarchy.
     * @param hierarchy the hierarchy string
     * @return the element Ids in a given hierarchy
     *  or null if no title found
     */
    public List<String> getElementIdsForHierarchy(String hierarchy) {
        List<String> elementIds = new ArrayList<String>();
        if (titleMap.containsValue(hierarchy)) {
            for (String key : titleMap.keySet()) {
                if (titleMap.get(key).equals(hierarchy)) {
                    elementIds.add(key);
                }
            }
            return elementIds;
        } else {
            return null;
        }
    }


    /**
     * Indexes pool selections by their assessment id.
     * @param elements the elements nested within the assessment
     * @param assessmentId the assessment id
     */
    public void indexPools(List<Element> elements, String assessmentId) {
        for (Element e : elements) {
            elementAssessmentMap.put(e.getAttributeValue("idref"), assessmentId);
            /////elementIdMap.put(e.getAttributeValue("idref"), assessmentId);
            // We do not add a key-value pair for the activityMap
            // since assessments do not contain Learning Objectives
        }
    }

    /**
     * Indexes activity elements by their Id.
     * @param elements the elements nested within the workbook
     * @param workbook the workbook containing the activity elements
     */
    public void indexActivities(List<Element> elements, Workbook workbook) {
        for (Element e : elements) {
            elementIdMap.put(e.getAttributeValue("idref"), workbook.getWorkbookId());
            activityMap.put(e.getAttributeValue("idref"), e);
        }
    }

    /**
     * Indexes inline elements by their Id.
     * @param elements the elements nested within the workbook
     * @param workbook the workbook containing the inline elements
     */
    public void indexInline(List<Element> elements, Workbook workbook) {
        for (Element e : elements) {

            elementIdMap.put(e.getAttributeValue("idref"), workbook.getWorkbookId());
            inlineMap.put(e.getAttributeValue("idref"), e);
        }
    }

    /**
     * Gets the purpose attribute for an in-line activity or activity.
     * @param problemName the problem name
     * @return the purpose
     */
    public String getPurpose(String problemName) {
        String purpose = null;
        Element element = null;
        if (inlineMap.containsKey(problemName)) {
            element = inlineMap.get(problemName);
        } else if (activityMap.containsKey(problemName)) {
            element = activityMap.get(problemName);
        }
        if (element != null && element.getAttributeValue("purpose") != null) {
            purpose = element.getAttributeValue("purpose");
        } else {
            logger.debug("No 'purpose' was found for problem: " + problemName  + ".");
        }
        return purpose;
    }

    /**
     * Indexes learning objectives by workbook.
     * @param elements the elements nested within the workbook
     * @param workbook the workbook
     */
    public void indexLearningObjectives(List<Element> elements, Workbook workbook) {
        for (Element e : elements) {
            addLearningObjective(e, workbook.getWorkbookId());
        }
    }

    /**
     * Gets the workbook Id from the nested element Id.
     * @param childId the nested element Id
     * @return the workbook Id or null if no workbook found
     */
    public String getWorkbookFromElementId(String childId) {
        if (elementIdMap.containsKey(childId)) {
            return elementIdMap.get(childId);
        } else if (elementAssessmentMap.containsKey(childId)) {
            return elementAssessmentMap.get(childId);
        }
        return null;
    }

    /**
     * Returns the element Ids in a given workbook.
     * @param workbookId the workbook Id
     * @return the element Ids in a given workbook
     *  or null if no Ids are found
     */
    public List<String> getElementsForWorkbook(String workbookId) {
        List<String> elementIds = new ArrayList<String>();
        if (elementIdMap.containsValue(workbookId)) {
            for (String key : elementIdMap.keySet()) {
                if (elementIdMap.get(key).equals(workbookId)) {
                    elementIds.add(key);
                }
            }
            return elementIds;
        } else {
            return null;
        }
    }

    /**
     * Returns the element Ids in a given assessment.
     * @param assessmentId the assessment Id
     * @return the element Ids in a given assessment
     *  or null if no Ids are found
     */
    public List<String> getElementsForAssessment(String assessmentId) {
        List<String> elementIds = new ArrayList<String>();
        if (elementAssessmentMap.containsValue(assessmentId)) {
            for (String key : elementAssessmentMap.keySet()) {
                if (elementAssessmentMap.get(key).equals(assessmentId)) {
                    elementIds.add(key);
                }
            }
            return elementIds;
        } else {
            return null;
        }
    }

    /** Gets the organization Id.
     * @return the organization Id
     */
    public String getId() {
        return this.id;
    }

    /**
     * Used to print all the 'problem' names and their workbooks.
     */
    public void debug() {
        logger.debug("Total resourceref elements: " + elementIdMap.size());
        for (String key : elementIdMap.keySet()) {
            logger.debug("Resourceref: " + key + " -> Workbook: " + elementIdMap.get(key));
        }
    }

    /**
     * Get a list of learning objective Elements for the given workbook.
     * @param workbookId the workbook Id
     * @return a list of learning objective Elements
     */
    public List<String> getLearningObjectivesFromWorkbook(String workbookId) {
        List<String> learningObjectives = new ArrayList<String>();
        List<Element> learningObjectiveReferences = new ArrayList<Element>();

        if (workbookId != null) {
            // Find all the learning objective references associated with this workbook Id
            for (Element objective : learningObjectiveMap.keySet()) {
                // Create a list of indirect references that match this workbook Id
                if (objective.getAttributeValue("idref") != null) {
                    // The list of workbooks associated with this objective
                    List<String> workbookList = learningObjectiveMap.get(objective);
                    for (String workbookIdMapped : workbookList) {
                        // Compare this workbook Id with those in the map
                        if (workbookId.equals(workbookIdMapped)) {
                            // Found a learning objective reference for this workbookId
                            learningObjectiveReferences.add(objective);
                            logger.debug("Adding learning objective reference: "
                                + objective.getAttributeValue("idref"));
                        }
                    }
                }
            }

            // Now, combine the LO references with the LO's in this workbook
            for (Element objective : learningObjectiveMap.keySet()) {
                if (objective.getAttributeValue("id") != null) {

                    for (Element objref : learningObjectiveReferences) {
                        // Add indirect references
                        if (objref.getAttributeValue("idref") != null
                                && objref.getAttributeValue("idref")
                                    .equals(objective.getAttributeValue("id"))) {
                            if (!learningObjectives.contains(objective.getAttributeValue("id"))) {
                                learningObjectives.add(objective.getAttributeValue("id"));
                                logger.debug("Adding learning objective: "
                                        + objective.getAttributeValue("id"));
                            }
                        }
                    }
                    // Add objectives in this workbook
                    for (String objectiveWorkbookId : learningObjectiveMap.get(objective)) {
                        if (objectiveWorkbookId.equals(workbookId)) {
                            if (!learningObjectives.contains(objective.getAttributeValue("id"))) {
                                learningObjectives.add(objective.getAttributeValue("id"));
                                logger.debug("Adding learning objective: "
                                        + objective.getAttributeValue("id"));
                            }
                        }
                    }

                }
            }
        }
        // Sort the LO's before returning them
        Collections.sort(learningObjectives);
        return learningObjectives;
    }

    /**
     * Gets the hierarchy description given the hierarchy.
     * @param hierarchy the hierarchy
     * @return the hierarchy description given the hierarchy.
     */
    public String getHierarchyDescription(String hierarchy) {
        return hierarchyDescriptions.get(hierarchy);
    }

    /**
     * Gets the title given the workbook Id.
     * @param workbookId the wokbook Id
     * @return the title given the workbook Id.
     */
    public String getWorkbookTitle(String workbookId) {
        return workbookTitles.get(workbookId);
    }

    /**
     * Adds a learning objective to the learning objective map.
     * @param objective the learning objective Element
     * @param workbookId the workbook Id
     */
    public void addLearningObjective(Element objective, String workbookId) {
        if (learningObjectiveMap.containsKey(objective)) {
            List<String> wbList = learningObjectiveMap.get(objective);
            if (!wbList.contains(workbookId)) {
                wbList.add(workbookId);
                learningObjectiveMap.put(objective, wbList);
            }

        } else {
            List<String> wbList = new ArrayList<String>();
            wbList.add(workbookId);
            learningObjectiveMap.put(objective, wbList);
        }

    }

    /**
     * Gets the text for a given learning objective Id.
     * @param objectiveId the learning objective Id
     * @return the text for a given learning objective Id
     */
    public Object getLearningObjectiveTitle(String objectiveId) {
        String title = null;
        for (Element objective : learningObjectiveMap.keySet()) {
            String mappedId = objective.getAttributeValue("id");
            if (mappedId != null && !mappedId.isEmpty()
                && mappedId.equals(objectiveId)) {
                    title = mappedId + " (" + objective.getText() + ")";
                }
        }

        return title;
    }

    /** Gets an inline element given a problem name.
     * @param problemName the problem name
     * @return inline the inline element
     */
    public Element getInline(String problemName) {
        Element inline = null;
        if (inlineMap.containsKey(problemName)) {
            inline = inlineMap.get(problemName);
        }
        return inline;
    }

    /** Gets an inline element given a problem name.
     * @param problemName the problem name
     * @return inline the inline element
     */
    public Element getActivity(String problemName) {
        Element activity = null;
        if (activityMap.containsKey(problemName)) {
            activity = activityMap.get(problemName);
        }
        return activity;
    }

    /**
     * Returns a list of workbooks for this organization.
     * @return a list of workbooks for this organization
     */
    public List<Workbook> getWorkbooks() {
        return workbooks;
    }

}
